<%
local FutureTimeoutParam = {
	name = "timeout",
	type = "number",
	eventual = "then no time limit is assumed",
	summary = "Minimum time to wait for the invocation completion",
	description = [[
		indicates the minimum time (in seconds) to wait for the completion of the invocation.
		If the invocation does not complete before this time this operation behaves as the invocation has raised a timeout exception.
	]],
}

return refman{
	--lingercfg = {
	--	type = "table",
	--	fields = {
	--		on = {
	--			type = "boolean",
	--			default = false,
	--			description = [[
	--			]],
	--		},
	--		timeout = {
	--			type = "number",
	--			description = [[
	--			]],
	--		},
	--	},
	--},
	tcpopt = {
		type = "table",
		summary = "TCP Options Table",
		fields = {
			keepalive = {
				type = "boolean",
				default = false,
				description = [[
					when is <code>true</code> enables the periodic transmission of messages on a connected socket.
					Should the connected party fail to respond to these messages, the connection is considered broken and processes using the socket are notified.
				]],
			},
			linger = {
				type = "table",
				default = nil,
				description = [[
					controls the action taken when unsent data are queued on a socket and a close is performed.
					The value is a table with a boolean entry <code>on</code> and a numeric entry for the time interval <code>timeout</code> in seconds.
					If the <code>on</code> field is set to <code>true</code>, the system will block the process on the close attempt until it is able to transmit the data or until <code>timeout</code> has passed.
					If <code>on</code> is <code>false</code> and a close is issued, the system will process the close in a manner that allows the process to continue as quickly as possible.
				]],
			},
			reuseaddr = {
				type = "boolean",
				default = false,
				description = [[
					when is <code>true</code> indicates that the rules used in validating addresses supplied in a call to bind should allow reuse of local addresses.
				]],
			},
			['tcp-nodelay'] = {
				type = "boolean",
				default = false,
				description = [[
					when is <code>true</code> disables the Nagle's algorithm for the connection.
				]],
			},
			timeout = {
				type = "number",
				default = false,
				description = [[
					defines the timeout in seconds of the sockets related operations invoked by the ORB.
				]],
			},
		},
	},
	orbcfg = {
		type = "table",
		summary = "ORB Configuration Table",
		fields = {
			flavor = {
				type = "string",
				default = "cooperative;corba",
				summary = "ORB assembly specification",
				description = [[
					contains a sequence of names describing how ORB internal components are created and assembled.
					These names determine the features provided by the ORB, including the underpinning RMI technology.
				]],
			},
			keyprefix = {
				type = "string",
				default = "_",
				summary = "Prefix of default object IDs",
				description = [[
					contains the prefix added to all object IDs automatically generated by the ORB for servants registed as distributed objects without an explicit object ID.
					Define this prefix to make the ORB to create object IDs that does not collides with the object IDs provided by your application.
				]],
			},
			objectmap = {
				type = "table",
				default = {},
				summary = "Map of active object IDs to servants",
				description = [[
					shall be used by the ORB to map the object ID of exported distributed objects to the servant that implements them.
					This table is used both to store servants registered by the application as well as to retrieve the servant of every invocation request dispatched by the ORB.
					Therefore, it is possible to provide a table with metamethods that provide servants to the ORB on demand.
				]],
			},
			localrefs = {
				type = "string",
				default = "implementation",
				summary = "Indication of how local references are resolved by the ORB",
				description = [[
					indicates how references to local servants must be resolved by the ORB so they can be delivered to the application.
					There are three expected values, that indicates that the local references shall be resolved to:
					<dl>
						<dt><code>"implementation"</code></dt>
						<dd>the value that implements the local object.</dd>
						<dt><code>"proxy"</code></dt>
						<dd>a new proxy to the local object.</dd>
						<dt><code>"servant"</code></dt>
						<dd>the servant object that represents the local object.</dd>
					</dl>
				]],
			},
			valuefactories = {
				type = "table",
				default = {},
				summary = "Map of type IDs to the corresponding factory",
				description = [[
					maps strings containing a type ID to the constructor function that shall be called by the ORB to resolve values of that type ID before passing the value to the application.
					The constructor function receives the raw data extracted from the wire and must adapt it properly so it can be delivered to the application.
				]],
			},
			host = {
				type = "string",
				default = "*",
				summary = "Network address the ORB must listen",
				description = [[
					contains address the ORB must listen when the ORB supports TCP connections.
					This address may be an IP address or a host name.
					Additionally, the value <code>"*"</code> indicates the ORB should listen to all TCP/IP network interfaces available.
				]],
			},
			port = {
				type = "number",
				default = 0,
				summary = "Network port number the ORB must listen",
				description = [[
					of a network port the ORB must listen when the ORB supports TCP connections.
					The value <code>0</code> indicates the ORB should choose a free ephemeral port automatically.
				]],
			},
			tcpoptions = {
				type = "tcpopt",
				default = {},
				summary = "Configuration of TCP connections created by the ORB",
				description = [[
					contains configuration options of the TCP connections created by the ORB when the underlying RMI technology creates such connections.
				]],
			},
		},
	},
	future = {
		type = "table",
		summary = "Future",
		description = [[
			Object that represents the results of a ongoing and potentially incomplete invocation initiated asynchronously.
		]],
		fields = {
			ready = {
				type = "method",
				summary = "Checks if the results are ready",
				description = [[
					checks whether the results of the invocation are ready or not.
				]],
				results = {
					{
						name = "completed",
						type = "boolean",
						summary = "Flag indicating the results are ready",
						description = [[
							is <code>true</code> when the results of the invocation were received and processed or <code>false</code> if the results are not available yet.
						]],
					},
				},
			},
			results = {
				type = "method",
				summary = "Returns the results of the invocation",
				description = [[
					blocks until the completion of the invocation (or a timeout) and returns its results.
				]],
				parameters = {
					FutureTimeoutParam,
				},
				results = {
					{
						name = "success",
						type = "boolean",
						summary = "Success flag of the invoked operation",
						description = [[
							is <code>true</code> when the invocation were performed successfully or <code>false</code> if there was an error while performing the invocation.
						]],
					},
					{
						name = "...",
						summary = "Values produced by the invoked operation",
						description = [[
							are the returned values of the invoked operation if it was performed successfully, otherwise it is the error raised while performing the invocation.
						]],
					},
				},
			},
			evaluate = {
				type = "method",
				summary = "Evaluate the invocation to completion",
				description = [[
					blocks until the completion of the invocation (or a timeout) and return the values returned by the operation or raises an error if the invocation could not be performed successfully.
					Any error raised by the invoked operation on the distributed object is raised by this method.
					If the asynchronous proxy that produced this future has any exception handler associated that matches an error raised during the operation invocation, the exception handler is called automatically.
				]],
				parameters = {
					FutureTimeoutParam,
				},
				results = {
					{
						name = "...",
						summary = "Values returned by the invoked operation",
						description = [[
							are the returned values of the invoked operation.
						]],
					},
				},
			},
		},
	},
	proxy = {
		type = "table",
		summary = "Proxy",
		description = [[
			Object used to access a distributed object.
			This object behaves as the distributed object.
			This means, that any method call performed on the proxy results in the same call on the distributed object.
			This object also provides the additional fields described below.
		]],
		fields = {
			__reference = {
				type = "table",
				summary = "Structure with reference information of the remote object",
				description = [[
					contains complete IOR structure (see CORBA::IOP::IOR in CORBA specs.) in case of CORBA ORB, or another data structure in case of other protocols.
				]],
			},
			__setexcatch = {
				type = "method",
				summary = "Defines a exception handling function for the proxy",
				description = [[
					defines the exception handling function for the proxy.
				]],
				parameters = {
					{
						name = "handler",
						type = "function",
						summary = "Exception handler function",
						description = [[
							is invoked to handle exceptions raised on operations invoked using a proxy.
							This function receives the following parameters:
							<dl>
								<dt>proxy</dt>
								<dd>object proxy that performed the operation.</dd>
								<dt>exception</dt>
								<dd>exception/error raised.</dd>
								<dt>operation</dt>
								<dd>descriptor of the operation that raised the exception.</dd>
							</dl>
							The results produced by this function (returned values or error raised) will become the results of the invocation that raised the exception.
						]],
					},
				},
				results = {
					{
						name = "success",
						type = "boolean",
						summary = "Indication that the timeout was changed",
					},
					{
						name = "result",
						type = {"function","error"},
						summary = "Result of the operation",
						description = [[
							is the previously defined exceptions handler function in case of success (<code>success == true</code>), or a message describing the error that occurred.
						]],
					},
				},
			},
			__settimeout = {
				type = "method",
				summary = "Defines a timeout for proxy invocations",
				description = [[
					defines the timeout for the methods invoked using proxies created by this ORB.
				]],
				parameters = {
					{
						name = "timeout",
						type = "number",
						summary = "Timeout in seconds",
						description = [[
							minimum time (in seconds) the ORB might spend to complete operations invoked using a proxy.
							Operations may complete before the time defined as the timeout.
						]],
					},
				},
				results = {
					{
						name = "success",
						type = "boolean",
						summary = "Indication that the timeout was changed",
					},
					{
						name = "result",
						type = {"number","error"},
						summary = "Result of the operation",
						description = [[
							is the previously defined timeout in case of success (<code>success == true</code>), or a message describing the error that occurred.
						]],
					},
				},
			},
		},
	},
	servant = {
		type = "table",
		summary = "Servant",
		description = [[
			Object that represents a value registered as servant that implements a distributed object.
			This object behaves as simplified proxy of the distributed object.
			This means, that any method call performed on the servant results in the same call on its implementation object.
			However, the invocations performed through this object does not go through the ORB, so marshalling and interceptions will not take place.
			This object also provides the additional fields described below.
		]],
		fields = {
			__servant = {
				summary = "Value registered as servant",
			},
			__objkey = {
				type = "string",
				summary = "Object key of the distributed object this servant implements",
			},
			__deactivate = {
				type = "method",
				summary = "Unregisters the servant from its broker.",
				description = [[
					unregisters the servant from its broker.
				]],
			},
		},
	},
	orb = {
		type = "table",
		summary = "Object Request Broker",
		fields = {
			newproxy = {
				type = "method",
				summary = "Creates a proxy of a distributed object",
				description = [[
					creates an object that works as a proxy of a distributed object indicated by a parameter <code>reference</code>.
					Every method invoked on the proxy results in an attempt to invoke the same method on the corresponding distributed object.
				]],
				parameters = {
					{
						name = "reference",
						type = {"string", "proxy"},
						summary = "Reference to distributed object",
						description = [[
							either a string containing object reference information (CORBA's stringfied IOR or CorbaLoc URI) of the distributed object or another proxy pointing to this object.
						]],
					},
					{
						name = "kind",
						type = "string",
						default = "synchronous",
						summary = "Proxy type",
						description = [[
							word indicating the kind of the proxy to be created.
							The possible options are:
							<dl>
								<dt><code>"synchronous"</code></dt>
								<dd>
									Proxy that imitates the behavior of the remote object.
									Its methods block while the corresponding method of the distributed object is executing and errors raised by the method of the distributed object are raised by the method of the proxy.
								</dd>
								<dt><code>"asynchronous"</code></dt>
								<dd>
									Proxy which methods might return before the completion of the invocation of the distributed object.
									The methods of this kind of proxy always return a <#future>.
								</dd>
								<dt><code>"protected"</code></dt>
								<dd>
									Proxy which methods never raise errors and always return a boolean indicating whether the invocation was perfomed successfully (<code>true</code>) or not (<code>false</code>), and also the results of the invocation, which are the returned values if the first value is <code>true</code>, or the error raised otherwise.
								</dd>
							</dl>
						]],
					},
					{
						name = "type",
						type = {"string", "type"},
						eventual = [[
							the ORB tries to infer a proper type for the distributed object, potentially trying to contact the object.
						]],
						summary = "Remote object type",
						description = [[
							indicates the type of the distributed object of the proxy to be created.
							It can either be a string with the absolute name or repository ID of an object interface previously loaded into the ORB, or an object describing the type.
							For more information about representation of object types and interface in a CORBA ORB see ]]..link("IDL")..[[
						]],
					},
				},
				results = {
					{
						name = "proxy",
						type = "proxy",
						summary = "Proxy of the distributed object",
						description = [[
							represents the referenced distributed object.
						]],
					},
				},
			},
			newservant = {
				type = "method",
				summary = "Registers a new servant creating a new distributed object",
				description = [[
					registers objects in the ORB as servants that implement distributed objects that shall be accessed remotely through the RMI technology supported by the ORB.
				]],
				parameters = {
					{
						name = "object",
						summary = "value that implements the distributed object",
						description = [[
							is a value that will be used to dispatch all requests to the distributed object created as result of this call.
							Usually, this value supports all the methods, attributes and other features of the distributed object.
							This value might provide the field <code>__objkey</code> to define the identifier used to register the servant in the ORB.
							Moreover, if the ORB supports interface definition of distributed objects (<em>e.g.</em> CORBA), this value might provide the field <code>__type</code> to define the interface of the distributed object implemented by this servant.
						]],
					},
					{
						name = "key",
						type = "string",
						summary = "Key identifying the distributed object implemented by the servant",
						description = [[
							containing a unique identifier of the distributed object implemented by the servant being registered in the ORB.
						]],
						eventual = [[
							the ORB creates an automatic key based on the parameter <code>value</code> and the distributed object interface.
							All automatically generated keys starts with a special prefix defined by the ORB configuration parameter <#orbcfg.keyprefix>.
						]],
					},
					{
						name = "type",
						type = {"string", "type"},
						summary = "Distributed object type",
						description = [[
							indicates the interface of the distributed object being created when the ORB provide support for this.
							For CORBA ORBs this parameter is mandatory.
						]],
						eventual = [[
							indicates that the ORB does not provide support for definition of the interface of distributed objects.
						]],
					},
				},
				results = {
					{
						name = "servant",
						type = "servant",
						summary = "Object representing the registered servant",
						description = [[
							represents a value registered as the implementation of a distributed object.
						]],
					},
				},
			},
			deactivate = {
				type = "method",
				summary = "Deactivates a distributed object.",
				description = [[
					deactivates a distributed object by removing its servant from the object map of the ORB.
				]],
				parameters = {
					{
						name = "key",
						type = {"string", "servant"},
						summary = "Identifier of the servant to be unregistered",
						description = [[
							is either the key identifying the servant, or the object representing the registered servant (as returned by method <#orb:newservant>).
							Moreover, this parameter can be the value registered as servant (as passed as parameter <code>servant</code> of method <#orb:newservant>).
							In this last case, if the value does not provide fields <code>__objkey</code> nor <code>__type</code>, it might be necessary to provide the same interface of the registered servant since the same value might be registered with different interfaces.
						]],
					},
					{
						name = "type",
						type = {"string", "type"},
						eventual = [[
							the ORB tries to infer the type of the registered servant automatically.
						]],
						summary = "Distributed object type",
						description = [[
							indicates the type of the distributed object being deactivated when the ORB provide support for this.
						]],
					},
				},
				results = {
					{
						name = "entry",
						type = "table",
						summary = "Servant entry in the object map",
						description = [[
							contains the following fields:
							<dl>
								<dt><code>__servant</code></dt>
								<dd>the value registered as servant.</dd>
								<dt><code>__objkey</code></dt>
								<dd>the identifier of the servant previously used to identify the servant in the ORB.</dd>
								<dt><code>__type</code></dt>
								<dd>the type information of the distributed object implemented by the servant.
								For ORBs with support for CORBA this field is the interface of the CORBA object implemented by the servant.</dd>
							</dl>
							If the ORB was unable to unregister the servant this returned value is <code>nil</code>.
						]],
					},
					{
						name = "errmsg",
						summary = "Error while unregistering the servant",
						eventual = "indicates the servant was unregistered successfully",
						description = [[
							describes the error that occurred.
						]],
					},
				},
			},
			pending = {
				type = "method",
				summary = "Checks whether there is some request pending",
				description = "checks whether there is some request pending processing by the ORB at the moment.",
				results = {
					{
						name = "ispending",
						type = "boolean",
						summary = "Indication whether there are requests pending processing",
						description = [[
							indicates whether there are requests pending processing in the ORB.
						]],
					},
				},
			},
			step = {
				type = "method",
				summary = "Process one single invocation request",
				description = [[
					waits for an invocation request and process it.
					Only one single invocation request is processed.
				]],
				parameters = {
					{
						name = "timeout",
						type = "number",
						summary = "time to wait for invocation requests",
						description = [[
							indicates the minimum time the ORB might wait for a new invocation request before processing it.
						]],
					}
				},
				results = {
					{
						name = "success",
						type = "boolean",
						summary = "Successful processing flag",
						description = [[
							indicates whether the invocation request was processed successfully.
						]],
					},
					{
						name = "errmsg",
						summary = "Error while processing the invocation request",
						eventual = "indicates the invocation request was processed successfully",
						description = [[
							describes the error that occurred.
						]],
					},
				},
			},
			run = {
				type = "method",
				summary = "Process incoming invocation requests continuously",
				description = [[
					processes all incoming invocation requests continuously until some error occours while receiving the requests or the method <#orb:shutdown>.
				]],
			},
			shutdown = {
				type = "method",
				summary = "stops the processing invocation requests",
				description = [[
					stops the execution of method <#orb:run>, so the invocation request processing halts.
					Any eventual invocation request that have started to be processed will be properly handled by the ORB before this method returns.
				]],
			},
			getinterceptor = {
				type = "method",
				summary = "Returns the current interceptor for invocations",
				description = [[
					returns the intereceptor registered to intercept invocation requests made through this ORB.
				]],
				parameters = {
					{
						name = "point",
						type = "string",
						summary = "Interception point name",
						eventual = [[
							indicates this method shall return the interceptor registered in both <code>"server"</code> and <code>"client"</code> interception points, or <code>nil</code> if there are two different interceptors.
						]],
						description = [[
							indicates the interception point, as defined by method <#orb:setinterceptor>
						]],
					},
				},
				results = {
					{
						name = "interceptor",
						type = "interceptor",
						summary = "Registered interceptor",
						description = [[
							was registered in the interception point indicated by parameter <code>point</code>.
						]],
					},
				},
			},
			setinterceptor = {
				type = "method",
				summary = "Defines an interceptor for invocations",
				description = [[
					registers an intereceptor to intercept invocation requests made through this ORB.
				]],
				parameters = {
					{
						name = "interceptor",
						type = "interceptor",
						summary = "Interceptor to be registered",
						description = [[
							to be invoked at some invocation interception point.
						]],
					},
					{
						name = "point",
						type = "string",
						summary = "Interception point",
						eventual = [[
							the interception point assumed is both the ones <code>"server"</code> and <code>"client"</code> values.
						]],
						description = [[
							indicates the interception point of the interceptor.
							The expected values are:
							<dl>
								<dt><code>"server"</code></dt>
								<dd>Interceptor is invoked whenever a request to a local servant is received or replied.</dd>
								<dt><code>"client"</code></dt>
								<dd>Interceptor is invoked whenever a request to a remote servant is sent or replied.</dd>
								<dt><code>"corba.server"</code></dt>
								<dd>Interceptor is invoked whenever a CORBA request to a local servant is received or replied.
								For more information on CORBA interceptors, see ]]..link("Intercept")..[[</dd>
								<dt><code>"corba.client"</code></dt>
								<dd>Interceptor is invoked whenever a CORBA request to a remote servant is sent or replied.
								For more information on CORBA interceptors, see ]]..link("Intercept")..[[</dd>
								<dt><code>"corba"</code></dt>
								<dd>Designates both interception points defined by values <code>"corba.client"</code> and <code>"corba.server"</code>.</dd>
							</dl>
						]],
					},
				},
			},
			getLIR = {
				type = "method",
				summary = "Returns the local repository with all known interface information",
				description = [[
					returns the internal CORBA Interface Repository used by the ORB.
					This method should not be invoked on ORBs that do not support CORBA.
				]],
				results = {
					{
						name = "repository",
						type = "table",
						summary = "Internal Interface Repository used by the ORB",
						description = [[
							implements the CORBA Interface Repository interface as specified by the CORBA standard to provide access to all the CORBA typing information known to the ORB.
						]],
					},
				},
			},
			getIR = {
				type = "method",
				summary = "Returns the remote repository used to discover interfaces",
				description = [[
					returns the CORBA Interface Repository (IR) used by the ORB to retrieve unknown typing information.
					Usually this IR is a proxy to a remote object that provides additional typing information that the ORB must retrieve on demmand.
					This method should not be invoked on ORBs that do not support CORBA.
				]],
				results = {
					{
						name = "repository",
						type = "table",
						summary = "External Interface Repository used by the ORB",
						description = [[
							implements the CORBA Interface Repository interface as specified by the CORBA standard to provide access to new the CORBA typing information unknown to the ORB.
						]],
					},
				},
			},
			setIR = {
				type = "method",
				summary = "Defines the remote repository used to discover interfaces",
				description = [[
					sets the CORBA Interface Repository (IR) used by the ORB to retrieve unknown typing information.
					Usually this IR is a proxy to a remote object that provides additional typing information that the ORB must retrieve on demmand.
					This method should not be invoked on ORBs that do not support CORBA.
				]],
				parameters = {
					{
						name = "repository",
						type = "table",
						summary = "External Interface Repository used by the ORB",
						description = [[
							implements the CORBA Interface Repository interface as specified by the CORBA standard to provide access to new the CORBA typing information unknown to the ORB.
						]],
					},
				},
			},
			setexhandler = {
				type = "method",
				summary = "Sets the dispatch exception handling function",
				description = [[
					sets a function to be called to manipulate an error raised during a dispatch and produce potentially new error value to be raised.
				]],
				parameters = {
					{
						name = "handler",
						type = "function",
						summary = "Dispatch exception handling function",
						description = [[
							executes in the same thread and execution point where the error was raised.
							This function receives as parameter the value of the original error raised during the dispatch of the servant and shall return the value of the error that must be raised in place of the original value.</dd>
							</dl>
						]],
					},
				},
			},
			setonerror = {
				type = "method",
				summary = "Sets a notification function for uncaught ORB errors",
				description = [[
					sets a function to be executed whenever the ORB catch an error that it cannot report back to the application.
				]],
				parameters = {
					{
						name = "callback",
						summary = "is called to notify an uncaught error.",
						description = [[
							is called to notify an uncaught error.
							This function cannot avoid the exception raised nor change the value of the error.
							It is simply a notification of an error raised.
							This function receives the following parameters:
							<dl>
								<dt>error</dt>
								<dd>the value of the uncaught error.</dd>
								<dt>tag</dt>
								<dd>an indication of the context where the error was raised.
								The possible values are:
									<dl>
										<dt>connection</dt>
										<dd>while connection establishment from a remote client.</dd>
										<dt>request</dt>
										<dd>while extracting request from remote client.</dd>
										<dt>dispatch</dt>
										<dd>while dispatching a request to the application.</dd>
										<dt>reply</dt>
										<dd>while sending a reply of an invocation back to the client.</dd>
									</dl>
								</dd>
							</dl>
						]],
					},
				},
			},
			setexcatch = {
				type = "method",
				summary = "Defines a exception handling function for proxies",
				description = [[
					defines the exception handling function for the proxies created by this ORB.
					Exception handling functions are not cumulative.
					For example, if there is an exception handling function defined for all proxies and another one only for proxies of a given type, then the later will be used for proxies of that given type.
					Additionally, exceptions handlers are not inherited through interface hierarchies.
				]],
				parameters = {
					{
						name = "handler",
						type = "function",
						summary = "Exception handler function",
						description = [[
							is invoked to handle exceptions raised on operations invoked using proxies created by this ORB.
							This function receives the following parameters:
							<dl>
								<dt>proxy</dt>
								<dd>object proxy that performed the operation.</dd>
								<dt>exception</dt>
								<dd>exception/error raised.</dd>
								<dt>operation</dt>
								<dd>descriptor of the operation that raised the exception.</dd>
							</dl>
						]],
					},
					{
						name = "interface",
						summary = "Interface of the proxies",
						description = [[
							defines an object interface, like an intefaces described in CORBA IDL.
							If this parameter is provided, then the exception handling function will be applied only to proxies of that interface.
						]],
						eventual = [[
							then the handler will be applied to all proxies created by the ORB that do not have a exception handler function defined.
						]],
					},
				},
			},
			settimeout = {
				type = "method",
				summary = "Defines a timeout for proxy invocations",
				description = [[
					defines the timeout for the methods invoked using proxies created by this ORB.
					Timeouts are not cumulative.
					For example, if there is a timeout defined for all proxies and another one only for proxies of a given type, then the later will be used for proxies of that given type.
					Additionally, timeouts are not inherited through interface hierarchies.
				]],
				parameters = {
					{
						name = "timeout",
						type = "number",
						summary = "Timeout in seconds",
						description = [[
							minimum time (in seconds) the ORB might spend to complete operations invoked using its proxies.
							Operations may complete before the time defined as the timeout.
						]],
					},
					{
						name = "interface",
						summary = "Interface of the proxies",
						description = [[
							defines an object interface, like intefaces described in CORBA IDL.
							If this parameter is provided, then the timeout will be applied only to proxies of that interface.
						]],
						eventual = [[
							then the timeout will be applied to all proxies created by the ORB that do not have a timeout defined.
						]],
					},
				},
			},
			newexcept = {
				type = "method",
				summary = "Creates a new exception object with the given body",
				description = [[
					creates a new exception object with the given body.
				]],
				parameters = {
					{
						name = "body",
						type = "table",
						description = [[
							contains the values of the exceptions fields.
							For ORBs that support typing information, like ORBs with CORBA support, the exception must also contain the type of the exception at field <code>_repid</code> (in CORBA this identification is the repository ID, absolute name, etc.).
						]],
					},
				},
				results = {
					{
						name = "exception",
						type = "table",
						description = [[
							contains the values of the exceptions fields and can be converted to string or concatenated to produce error messages.
						]],
					},
				},
			},
			newdecoder = {
				type = "method",
				summary = "Creates a new value decoder that unmarshal values from strings",
				description = [[
					creates a new value decoder that unmarshal values from an encoded stream.
					For CORBA ORBs, the decoder reads CORBA's CDR encapsulated streams, <i>i.e.</i> includes an indication of the endianess used in value codification.
				]],
				parameters = {
					{
						name = "stream",
						type = "string",
						description = [[
							contains a stream with marshaled values.
						]],
					},
				},
				results = {
					{
						name = "decoder",
						type = "decoder",
						description = [[
							is a value decoder that can be used to unmarshal values from a marshaled stream.
						]],
					},
				},
			},
			newencoder = {
				type = "method",
				summary = "Creates a new value encoder that marshal values into strings",
				description = [[
					creates a new value encoder that marshal values into an encoded stream.
					For CORBA ORBs, the encoder writes CORBA's CDR encapsulated streams, <i>i.e.</i> includes an indication of the endianess used in value codification.
				]],
				results = {
					{
						name = "encoder",
						type = "encoder",
						description = [[
							is a value encoder that can be used to marshal values into a string containing a marshaled stream.
						]],
					},
				},
			},
			narrow = {
				type = "method",
				summary = "Narrows an object reference into a more specific interface",
				description = [[
					narrows an object proxy into a more specific interface.
					This method is deprecated.
					Use <#orb:newproxy> instead.
				]],
				parameters = {
					{
						name = "proxy",
						type = "proxy",
						summary = "Reference to distributed object",
						description = [[
							points to the distributed object being narrowed.
						]],
					},
					{
						name = "type",
						type = {"string", "type"},
						summary = "Remote object type",
						description = [[
							indicates the type of the distributed object of the proxy to be created.
							It can either be a string with the absolute name or repository ID of an object interface previously loaded into the ORB, or an object describing the type.
							For more information about representation of object types and interface in a CORBA ORB see ]]..link("IDL")..[[
						]],
						eventual = [[
							the ORB tries to infer the more specific type for the distributed object, potentially trying to contact the object.
						]],
					},
				},
				results = {
					{
						name = "proxy",
						type = "proxy",
						summary = "Narrower proxy of the distributed object",
						description = [[
							represents the referenced distributed object with a narrower interface.
						]],
					},
				},
			},
			loadidl = {
				type = "method",
				summary = "Loads an IDL definition into the internal Interface Repository",
				description = [[
					loads an IDL definition into the internal Interface Repository.
				]],
				parameters = {
					{
						name = "idlspec",
						type = "string",
						summary = "The IDL specification to be loaded into the internal IR",
						description = [[
							contains an IDL specification of interfaces and other typing information to be loaded into the ORB's internal Interface Repository (see <$orb:getLIR>).
							This IDL specification will be parsed by the LuaIDL compiler.
						]],
					},
					{
						name = "incpaths",
						type = "table",
						summary = "",
						description = [[
							contains a sequence of file paths (string) to search for files included using <code>#include</code> directive.
						]],
						eventual = [[
							the included files are searched only in the default places, which are the current directory and the directory of the file containing the <code>#include</code> directive.
						]],
					},
				},
				results = {
					{
						name = "...",
						summary = "",
						description = [[
							are values that implement descriptors of the loaded definitions.
							For more information about IDL descriptors, see ]]..link("IDL")..[[
						]],
					},
				},
			},
			loadidlfile = {
				type = "method",
				summary = "Loads an IDL file into the internal Interface Repository",
				description = [[
					loads an IDL definition from a file into the internal Interface Repository.
				]],
				parameters = {
					{
						name = "filepath",
						type = "string",
						summary = "Path to file with IDL specification to be loaded into the internal IR",
						description = [[
							contains a path to a file containing an IDL specification of interfaces and other typing information to be loaded into the ORB's internal Interface Repository (see <$orb:getLIR>).
							The contents of this file will be parsed by the LuaIDL compiler.
						]],
					},
					{
						name = "incpaths",
						type = "table",
						summary = "",
						description = [[
							contains a sequence of file paths (string) to search for files included using <code>#include</code> directive.
						]],
						eventual = [[
							the included files are searched only in the default places, which are the current directory and the directory of the file containing the <code>#include</code> directive.
						]],
					},
				},
				results = {
					{
						name = "...",
						summary = "",
						description = [[
							are values that implement descriptors of the loaded definitions.
							For more information about IDL descriptors, see ]]..link("IDL")..[[
						]],
					},
				},
			},
		},
	},
	interceptor = {
		type = "table",
		summary = "Invocation Interceptor",
		fields = {
			sendrequest = {
				type = "method",
				summary = "Client-side invocation request interception point",
				description = [[
					is invoked whenever the ORB send an invocation request.
				]],
				parameters = {
					{
						name = "request",
						type = "reqcli",
						description = [[
							describes the invocation being intercepted.
						]],
					}
				},
			},
			receivereply = {
				type = "method",
				summary = "Client-side invocation reply interception point",
				description = [[
					is invoked whenever the ORB receives the reply of an invocation request sent previously.
				]],
				parameters = {
					{
						name = "request",
						type = "reqcli",
						description = [[
							describes the invocation being intercepted.
							This is the same table passed to the corresponding <#interceptor:sendrequest>
						]],
					}
				},
			},
			receiverequest = {
				type = "method",
				summary = "Server-side invocation request interception point",
				description = [[
					is invoked whenever the ORB receives an invocation request.
				]],
				parameters = {
					{
						name = "request",
						type = "reqsrv",
						description = [[
							describes the invocation being intercepted.
						]],
					}
				},
			},
			sendreply = {
				type = "method",
				summary = "Server-side invocation reply interception point",
				description = [[
					is invoked whenever the ORB sends a reply of an invocation request received previously.
				]],
				parameters = {
					{
						name = "request",
						type = "reqsrv",
						description = [[
							describes the invocation being intercepted.
							This is the same table passed to the corresponding <#interceptor:receiverequest>
						]],
					}
				},
			},
		},
	},
	request = {
		type = "table",
		summary = "CORBA Invocation Request",
		fields = {
			request_id = {
				type = "number",
				readonly = true,
				description = [[
					identifies the pending request over the connection used to communicate with the remote ORB.
					Note that this identifier is not unique across different connections, and it may be reused by other requests after this one is completed (<em>i.e.</em> replied).
				]],
			},
			response_expected = {
				type = "boolean",
				description = [[
					indicates if the server must send a response for this request.
				]],
			},
			reference = {
				type = "table",
				readonly = true,
				description = [[
					contains the complete IOR structure (see <code>CORBA::IOP::IOR</code> in CORBA specs.) that identifies the servant the request is sent to.
				]],
			},
			object_key = {
				type = "string",
				description = [[
					contains the key of the object the request is addressed to.</td>
					If the ORB is not able to decode an IOR profile, this field is <code>nil</code>.
				]],
			},
			interface = {
				type = "table",
				readonly = true,
				description = [[
					contains the complete description of the interface of the servant being invoked.
				]],
			},
			operation = {
				type = "table",
				description = [[
					is an object with the complete description of the operation being invoked.
					To change the operation being invoked on the remote servant, the application must set a new operation description to this field, which can be obtained from the local Interface Repository (see method <#orb:getLIR>)
				]],
			},
			operation_name = {
				type = "string",
				readonly = true,
				description = [[
					contains the name of the operation being invoked.
				]],
			},
			parameters = {
				type = "table",
				description = [[
					contains a list of the parameters passed to the operation being invoked.
				]],
			},
			service_context = {
				type = "table",
				description = [[
					maps each service context ID to a service context data to be marshaled in the request.
					If no service context data is provided then this field is <code>nil</code>.
				]],
			},
			success = {
				type = "boolean",
				description = [[
					indicates whether the invocation request resulted in successful results (<code>true</code>) or in an error (<code>false</code>).
					If the request has not completed yet, this field is <code>nil</code>.
					The interceptor might set this field with a boolean value to cancel the request.
				]],
			},
			results = {
				type = "table",
				description = [[
					contains either a list of the values to be returned (in case of a successful invocation) or a list with a single value indicating the raised exception or error (in case of a failed invocation).
					Set this value to provide the result values of a canceled request.
					If the request have no results yet, this field is <code>nil</code>.
				]],
			},
			reply_service_context = {
				type = "table",
				description = [[
					maps each service context ID to a service context data to be added to the reply of a cancelled request.
					If no service context data is provided then this field is <code>nil</code>.
				]],
			},
			forward_reference = {
				type = "table",
				description = [[
					contains a complete IOR structure (see <code>CORBA::IOP::IOR</code> in CORBA specs.) indicating that this request shall be forwarded to this reference.
					Set this value to forward this request to another reference.
				]],
			},
		},
	},
	reqsrv = {
		type = "table",
		summary = "CORBA Server Invocation Request",
		description = [[
			Object that describes an intercepted CORBA invocation request  on the server-side.
			This table provides the same fields of the <#request>.
		]],
		fields = {
			servant = {
				readonly = true,
				description = [[
					is the value registered as the servant of the invoked object.
					If the ORB cannot find a suitable target servant then this field is <code>nil</code>.
				]],
			},
			channel_address = {
				type = "table",
				description = [[
					contains information about the remote address of the channel that received the request.
					Note that this address information is about the last hop that delivered the message, and might not necessarly reflect the address that originally requested the invocation.
					For requests receives using IIOP (default and only GIOP supported by standard OiL) this table contains fields <code>host</code> and <code>port</code> containing respectively a string and a number indicating the IP address and port of the remote end of the channel.
				]],
			},
		},
	},
	reqcli = {
		type = "table",
		summary = "CORBA Client Invocation Request",
		description = [[
			Object that describes an intercepted CORBA invocation request on the client-side.
			This table provides the same fields of the <#request>.
		]],
		fields = {
			profile_tag = {
				type = "number",
				readonly = true,
				description = [[
					is the identification of the kind of the IOR profile used to establish a connection with the servant's ORB.
					If the ORB is not able to establish a connection, this field is <code>nil</code>.
				]],
			},
			profile_data = {
				type = "string",
				readonly = true,
				description = [[
					contains the encoded profile data used to establish a connection with the servant's ORB.
					If the ORB is not able to establish a connection, this field is <code>nil</code>.
				]],
			},
			profile = {
				type = "table",
				readonly = true,
				description = [[
					contains the decoded profile data used to establish a connection with the servant's ORB.
					If the ORB is not able to establish a connection, this field is <code>nil</code>.
					The structure of this profile depends on the value of the <code>profile_tag</code>.
					For IIOP profiles (<code>profile_tag == 0</code>), this table follows the structure of <code>CORBA::IIOP::ProfileBody_1_0</code>.
				]],
			},
		},
	},
	oil = {
		type = "table",
		summary = "OiL Module",
		fields = {
			init = {
				type = "function",
				summary = "Initialize an ORB (broker)",
				description = [[
					initializes an ORB (broker) instance on table <code>config</code> using its fields as configuration options.
				]],
				parameters = {
					{
						name = "config",
						type = "orbcfg",
						summary = "ORB configuration parameters",
						description = [[
							contains optional configuration parameters of the initialized ORB.
							The actual configuration options varies accordingly to the ]]..link("Flavors","ORB flavor")..[[.
							For more information, see section ]]..link("Brokers")..[[.
						]],
						eventual = [[
							this method returns the same ORB, which is initialized with default configuration options.
							To create different ORBs with the default configuration, pass a different empty table as this parameter
						]],
					},
				},
				results = {
					{
						name = "orb",
						type = "orb",
						summary = "Initialized ORB",
						description = [[
							is the same table <code>config</code> now containing an initialized ORB and all values of the configuration options used, including default values adopted.
							This returned table shall not be modified by the application.
						]],
					},
				},
				examples = {
					[[orb = oil.init{ host="orb.tecgraf.puc-rio.br" }]],
					[[oil.init{ host="10.223.10.56", port=2089 }:run()]],
					[[print("Default port chosen:", oil.init().port)]],
				},
			},
			main = {
				type = "function",
				parameters = {
					{
						name = "func",
						type = "function",
						summary = "Function that starts the application",
						description = [[
							shall be executed and runs the whole application.
							Ideally, this function is the initial entry point of the application.
						]],
					},
					{
						name = "...",
						summary = "Parameters for the function to be executed",
						description = [[
							are the values to be passed as arguments to the function being executed.
						]],
					},
				},
				results = {
					{
						name = "...",
						summary = "Results of the execution",
						description = [[
							are all the values returned or yielded by the last executed function during this execution.
							These values might be the values produced by function <code>func</code> itself or some other function executed in another thread that terminated or suspended after the thread running <code>func</code> has completed or suspended.
						]],
					},
				},
				summary = "Executes the application's main function",
				description = [[
					executes the application's main function in a new thread if the OiL module loaded provides thread support.
					This function only returns when the main function and all threads initiated by this function terminates or suspends.
				]],
				examples = {
					[[oil.main(function() print(oil.getLIR()) oil.run() end)]],
				},
			},
			newthread = {
				type = "function",
				parameters = {
					{
						name = "func",
						type = "function",
						summary = "Function to be executed in a new thread",
						description = [[
							shall be executed in a new thread.
						]],
					},
					{
						name = "...",
						summary = "Parameters for the function to be executed",
						description = [[
							are the values to be passed as arguments to the function being executed.
						]],
					},
				},
				results = {
					{
						name = "...",
						summary = "Results of the execution",
						description = [[
							are all the values returned or yielded by the the executed function.
						]],
					},
				},
				summary = "Executes a function in a new thread",
				description = [[
					creates a new thread to execute a function with the arguments provided.
					This function immediately starts the execution of the new thread and returns only when the new thread yields or returns.
					This function returns all the values yielded by the new thread.
					This function can only be invoked from others threads, including the one executing the application's main function (see <#oil.main>).
				]],
				examples = {
					[[oil.newthread(broker.run, broker)]],
				},
			},
			sleep = {
				type = "function",
				parameters = {
					{
						name = "time",
						type = "number",
						summary = "Time of the suspension in seconds",
						description = [[
							is the minimum number of seconds the current thread must be suspended.
						]],
					},
				},
				summary = "Suspends the current thread for some time.",
				description = [[
					suspends the execution of the current thread for a minimum ammount of time.
					Thus function only return after the time counter of system has passed the specified time.
				]],
				examples = {
					[[oil.sleep(5.5)]],
				},
			},
			time = {
				type = "function",
				summary = "Returns the current time of the system.",
				description = "returns the current time of the system.",
				results = {
					{
						name = "time",
						type = "number",
						summary = "Time of the system in seconds",
						description = [[
							indicates the current time of the system in seconds, counting from an arbitraty fixed moment in the past.
						]],
					},
				},
				examples = {
					[[start = oil.time(); oil.sleep(3); print("slept for ", oil.time()-start, " secs.")]],
				},
			},
			readfrom = {
				type = "function",
				parameters = {
					{
						name = "filepath",
						type = "string",
						summary = "Path to the file to be read",
						description = [[
							contains the path to the file to be read.
						]],
					},
					{
						name = "binary",
						type = "boolean",
						summary = "Binary mode flag",
						description = [[
							indicates whether the file should be read as a binary stream.
						]],
					},
				},
				results = {
					{
						name = "contents",
						type = "string",
						summary = "Contents read from the file",
						description = [[
							contains the entire contents of the file.
							In case of errors, this returned value is <code>nil</code>.
						]],
					},
					{
						name = "errmsg",
						type = "string",
						summary = "Error while reading the file",
						eventual = "indicates the file was read successfully",
						description = [[
							an message describing the error that occurred.
						]],
					},
				},
				summary = "Reads the contents of a file.",
				description = [[
					reads the entire contents of a file either as text or a binary stream.
				]],
				examples = {
					[[orb:newproxy(oil.readfrom("object.ref"))]],
				},
			},
			writeto = {
				type = "function",
				parameters = {
					{
						name = "filepath",
						type = "string",
						summary = "Path to the file to be written",
						description = [[
							contains the path to the file to be written.
						]],
					},
					{
						name = "data",
						summary = "Data to be written to the file",
						description = [[
							is the value which the textual representation (as produced by function ]]..link"LuaManual.tostring"..[[ from the ]]..link"LuaManual.StdLibs"..[[) shall be written to the file.
						]],
					},
					{
						name = "mode",
						type = "string",
						default = "w",
						summary = "Write mode flags",
						description = [[
							indicated the mode how the file should be accessed like specified by function ]]..link"LuaManual.io.open"..[[ from the ]]..link"LuaManual.StdLibs"..[[.
						]],
					},
				},
				results = {
					{
						name = "success",
						type = "boolean",
						summary = "Indication of success",
						description = [[
							indicates whether the data was written successfully.
						]],
					},
					{
						name = "errmsg",
						type = "string",
						summary = "Error while writing the file",
						eventual = "indicates the file was read successfully",
						description = [[
							an message describing the error that occurred.
						]],
					},
				},
				summary = "Write data to a file.",
				description = [[
					writes the textual representation of a value to a file.
				]],
				examples = {
					[[oil.writeto("ir.ior", orb:getLIR())]],
				},
			},
		},
	},
}

--[===[
	},
	orb = { "object",
		setexcatch = {
			parameters = "function [, interface]",
			summary = "Defines a exception handling function for proxies",
		},
		newexcept = {
			parameters = "body",
			results = "exception",
			summary = "Creates a new exception object with the given body",
		},
		newdecoder = {
			parameters = "stream",
			results = "decoder",
			summary = "Creates a new value decoder that unmarshal values from an encoded stream",
		},
		newencoder = {
			results = "encoder",
			summary = "Creates a new value encoder that marshal values into strings",
		},
		narrow = {
			parameters = "proxy, [interface]",
			results = "proxy",
			summary = "Narrows an object reference into some more specific interface",
		},
		loadidl = {
			parameters = "idlcode [, incpaths]",
			results = "...",
			summary = "Loads an IDL definition into the internal Interface Repository",
		},
		loadidlfile = {
			parameters = "filepath [, incpaths]",
			results = "...",
			summary = "Loads an IDL file into the internal Interface Repository",
		},
	},
}
--]===]
%>
