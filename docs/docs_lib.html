<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<title>OiL: The Lua Object Request Broker Project</title>
<style type="text/css" media="all"><!--
@import "oil.css";
@import "layout1.css";
dt { margin-top: 10px; }
table { padding-left: 10px; }
--></style>
</head>

<body>

<div id="Header"><h3>The Lua Object Request Broker</h3></div>
<div id="Logo"><img alt="small (1K)" src="small.gif" height="49" width="80" /></div>

<div id="Menu">
	<h3>Menu</h3>
	<hr>
	<p>
		<a href="index.html" title="OiL site main page">Home</a><br>
		<a href="install.html" title="Installation instructions">Install</a><br>
		<a href="docs.html" title="User manual">Manual</a><br>
			<ul>
				<li><a href="docs_lib.html" title="Main library programming interface">Library API</a><br></li>
				<li><a href="docs_obj.html" title="Object implementation and access">CORBA Objects</a><br></li>
				<li><a href="docs_map.html" title="CORBA type mapping into Lua">Type Mapping</a><br></li>
			</ul>
		<a href="papers.html" title="Published papers">Papers</a><br>
		<a href="features.html" title="List of features currently supported">Features</a><br>
		<a href="versions.html" title="List of all versions of OiL">Versions</a><br>
		<a href="people.html" title="Who does develop the OiL?">People</a><br>
		<a href="http://www.luaforge.net/projects/oil" title="Project page at LuaForge">LuaForge</a><br>
	</p>
</div>

<div class="content">
	<h1>Library API</h1>

	<p>This API provides access to the basic functionalities of the OiL ORB.
	More advanced features may be accessed through more specialized interfaces provided by internal components. OiL internal component organization is meant to be customized for the application.</p>
	
	<h3>Fields</h3>
	<dl>
		<dt><a href="#Config"><b><code>oil.Config</code></b></a></dt> 
		<dd>Configuration used to create the main ORB.</dd>
		<dt><a href="#tasks"><b><code>oil.tasks</code></b></a></dt> 
		<dd>Internal coroutine scheduler used by OiL.</dd>
		<dt><a href="#types"><b><code>oil.types</code></b></a></dt> 
		<dd>Internal interface repository used by the ORB.</dd>
	</dl>

	<h3>Functions</h3>
	<dl>
		<dt><a href="#deactivate"><b><code>oil.deactivate</code></b></a><code>(object)</code></dt>
		<dd>Deactivates a servant by removing its implementation from the object map.</dd>
		<dt><a href="#getIR"><b><code>oil.getIR</code></b></a><code>()</code></dt>
		<dd>Gets the Interface Repository used to retrieve interface definitions.</dd>
		<dt><a href="#getLIR"><b><code>oil.getLIR</code></b></a><code>()</code></dt>
		<dd>Gets a reference to the integrated Interface Repository.</dd>
		<dt><a href="#init"><b><code>oil.init</code></b></a><code>([config])</code></dt>
		<dd>Initialize the main ORB.</dd>
		<dt><a href="#loadidl"><b><code>oil.loadidl</code></b></a><code>(idlcode)</code></dt>
		<dd>Loads an IDL definition into the internal Interface Repository.</dd>
		<dt><a href="#loadidlfile"><b><code>oil.loadidlfile</code></b></a><code>(filename)</code></dt>
		<dd>Loads an IDL file into the internal Interface Repository.</dd>
		<dt><a href="#main"><b><code>oil.main</code></b></a><code>(function)</code></dt>
		<dd>Function executes the main function of the application.</dd>
		<dt><a href="#narrow"><b><code>oil.narrow</code></b></a><code>(proxy, [interface])</code></dt>
		<dd>Narrows an object reference into some more specific interface.</dd>
		<dt><a href="#newdecoder"><b><code>oil.newdecoder</code></b></a><code>(stream)</code></dt>
		<dd>Creates a new value decoder that marshal values into strings.</dd>
		<dt><a href="#newencoder"><b><code>oil.newencoder</code></b></a><code>()</code></dt>
		<dd>Creates a new value encoder that marshal values into strings.</dd>
		<dt><a href="#newexcept"><b><code>oil.newexcept</code></b></a><code>(body)</code></dt>
		<dd>Creates a new exception object with the given body.</dd>
		<dt><a href="#newproxy"><b><code>oil.newproxy</code></b></a><code>(reference, [interface])</code></dt>
		<dd>Creates a proxy for a remote object defined by a textual reference.</dd>
		<dt><a href="#newservant"><b><code>oil.newservant</code></b></a><code>(impl, interface, [key])</code></dt>
		<dd>Creates a new servant implemented in Lua that supports some interface.</dd>
		<dt><a href="#newthread"><b><code>oil.newthread</code></b></a><code>(function, ...)</code></dt>
		<dd>Creates and starts the execution of a new the thread.</dd>
		<dt><a href="#pcall"><b><code>oil.pcall</code></b></a><code>(function, ...)</code></dt>
		<dd>Function that must be used to perform protected calls in applications.</dd>
		<dt><a href="#pending"><b><code>oil.pending</code></b></a><code>()</code></dt>
		<dd>Checks whether there is some request pending.</dd>
		<dt><a href="#readfrom"><b><code>oil.readfrom</code></b></a><code>(filename)</code></dt>
		<dd>Read the contents of a file.</dd>
		<dt><a href="#run"><b><code>oil.run</code></b></a><code>()</code></dt>
		<dd>Runs the ORB main loop.</dd>
		<dt><a href="#setclientinterceptor"><b><code>oil.setclientinterceptor</code></b></a><code>([interceptor])</code></dt>
		<dd>Sets a CORBA-specific interceptor for operation invocations in the client-size.</dd>
		<dt><a href="#setexcatch"><b><code>oil.setexcatch</code></b></a><code>(function, [interface])</code></dt>
		<dd>Defines a exception handling function for proxies.</dd>
		<dt><a href="#setIR"><b><code>oil.setIR</code></b></a><code>(remoteIR)</code></dt>
		<dd>Sets the Interface Repository used to retrieve interface definitions.</dd>
		<dt><a href="#setserverinterceptor"><b><code>oil.setserverinterceptor</code></b></a><code>([interceptor])</code></dt>
		<dd>Sets a CORBA-specific interceptor for operation invocations in the server-size.</dd>
		<dt><a href="#shutdown"><b><code>oil.shutdown</code></b></a><code>()</code></dt>
		<dd>Shuts down the ORB.</dd>
		<dt><a href="#sleep"><b><code>oil.sleep</code></b></a><code>(delay)</code></dt>
		<dd>Suspends the execution of the current thread for some time.</dd>
		<dt><a href="#step"><b><code>oil.step</code></b></a><code>()</code></dt>
		<dd>Waits for an ORB request and process it.</dd>
		<dt><a href="#time"><b><code>oil.time</code></b></a><code>()</code></dt>
		<dd>Get the current system time.</dd>
		<dt><a href="#tostring"><b><code>oil.tostring</code></b></a><code>(object)</code></dt>
		<dd>Returns textual information that identifies the servant.</dd>
		<dt><a href="#writeto"><b><code>oil.writeto</code></b></a><code>(filename, text)</code></dt>
		<dd>Writes a text into file.</dd>
	</dl>
	
	<h3>Aliases</h3>
	<dl>
		<dt><a href="#newobject"><b><code>oil.newobject</code></b></a></dt>
		<dd>Alias of <code>oil.newservant</code> function.</dd>
		<dt><a href="#createservant"><b><code>oil.createservant</code></b></a></dt>
		<dd>Alias of <code>oil.newservant</code> function.</dd>
		<dt><a href="#createproxy"><b><code>oil.createproxy</code></b></a></dt>
		<dd>Alias of <code>oil.newproxy</code> function.</dd>
	</dl>
	
	<h3>Definitions</h3>
	
	<dl>
		<dt><a name="Config"><b><code>oil.Config</code></b></a></dt>
		<dd>
		<p>
			<b>Configuration used to initialize the main ORB.</b>
			The configuration values may differ accordingly to the underlying protocol.
			For CORBA's Internet IOP (IIOP) protocol the current options are the host name or IP address and port that ORB must bind to, as well as the host name or IP address and port that must be used in creation of object references.<br>
		<p>
			<i>Table Fields:</i>
			<table>
			<tr>
				<td valign="top"><code>host</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top">[optional]</td>
				<td>Host name or IP address. If none is provided the ORB binds to all current net interfaces.</td>
			</tr>
			<tr>
				<td valign="top"><code>port</code></td>
				<td valign="top"><b>number</b></td>
				<td valign="top">[optional]</td>
				<td>Host port the ORB must listen. If none is provided, the ORB tries to bind to a port in the range [2809; 9999].</td>
			</tr>
			<tr>
				<td valign="top"><code>refhost</code></td>
				<td valign="top"><b>string</td>
				<td valign="top">[optional]</td>
				<td>Host name or IP address informed in object references.</td>
			</tr>
			<tr>
				<td valign="top"><code>refport</code></td>
				<td valign="top"><b>number</b></td>
				<td valign="top">[optional]</td>
				<td>Host port informed in object references.</td>
			</tr>
			<tr>
				<td valign="top"><code>tag</code></td>
				<td valign="top"><b>number</b></td>
				<td valign="top">[optional]</td>
				<td>Tag of the IOP protocol the ORB shall use. The default is 0 that indicates the Internet IOP (IIOP).</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.Config.host = "middleware.inf.puc-rio.br"
oil.Config.host = "10.223.10.56"
oil.Config.port = 8080
oil.Config = {host = "10.223.10.56", port = 8080 }
			</pre>
		</dd>
		
		<dt><a name="init"><b><code>oil.init</code></b></a><code>([config])</code></dt>
		<dd>
		<p>
			<b>Initialize the main ORB.</b>
			Initialize the default ORB instance with the provided configurations like described in <code>Config</code>.
			If the default ORB already is created then this instance is returned.
			This default ORB is used by all objects and proxies created by newsevant and newproxy functions.<br>
		<p>
			<i>Parameters</i>
			<table>
			<tr>
				<td valign="top"><code>config</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top">[optional]</td>
				<td>Configuration used to initialize the main ORB instance.</td>
			</tr>
			</table>
		<p>
			<i>Return values</i>
			<table>
			<tr>
				<td valign="top"><code>actualconfig</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Configuration values actually used by the ORB instance.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.init{ host = "middleware.inf.puc-rio.br" }
oil.init{ host = "10.223.10.56", port = 8080 }
print("ORB post:", oil.init().port)
			</pre>
		<p>
			<i>See also:</i> <a href="#Config"><b><code>oil.Config</code></b></a>
		</dd>
		
		<dt><a name="pending"><b><code>oil.pending</code></b></a><code>()</code></dt>
		<dd>
		<p>
			<b>Checks whether there is some request pending.</b>
			Function used to check whether there is some unprocessed ORB request pending.
			It returns <code>true</code> if there is some request pending that must be processed by the main ORB or <code>false</code> otherwise.<br>
		<p>
			<i>Return values</i>
			<table>
			<tr>
				<td valign="top"><code>ispending</code></td>
				<td valign="top"><b>boolean</b></td>
				<td valign="top"></td>
				<td>Indication that there is some request pending.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
while oil.pending() do
	oil.step()
end
			</pre>
		</dd>
		
		<dt><a name="step"><b><code>oil.step</code></b></a><code>()</code></dt>
		<dd>
		<p>
			<b>Waits for an ORB request and process it.</b>
			Function used to wait for an ORB request and process it.
			Only one single ORB request is processed at each call.
			It returns <code>true</code> if no exception is raised during request processing, or <code>nil</code> and the raised exception otherwise.<br>
		<p>
			<i>Return values</i>
			<table>
			<tr>
				<td valign="top"><code>success</code></td>
				<td valign="top"><b>boolean</b></td>
				<td valign="top"></td>
				<td>Indication of success on request processing.</td>
			</tr>
			<tr>
				<td valign="top"><code>exception</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top">[occasional]</td>
				<td>Exception raised at request processing.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
while oil.step() do
  print "One more request successfully processed!"
end
			</pre>
		</dd>
		
		<dt><a name="run"><b><code>oil.run</code></b></a><code>()</code></dt>
		<dd>
		<p>
			<b>Runs the ORB main loop.</b>
			Function used to process all remote requisitions continuously until some exception is raised.
			This function implicitly initiates the ORB if it was not initialized yet.<br>
		<p>
			<i>Usage:</i>
			<pre>oil.run()</pre>
		</dd>
		
		<dt><a name="shutdown"><b><code>oil.shutdown</code></b></a><code>()</code></dt>
		<dd>
		<p>
			<b>Shuts down the ORB.</b>
			Stops the ORB main loop if it is executing.
			All pending requests will be properly handled by the ORB after this function returns.<br>
		<p>
			<i>Usage:</i>
			<pre>oil.shutdown()</pre>
		</dd>
		
		<dt><a name="types"><b><code>oil.types</code></b></a></dt>
		<dd>
		<p>
			<b>Internal Interface Repository used by OiL.</b>
			This field holds a reference to the object that implement the CORBA's Interface Repository used by the main ORB.
			It implements the API defined by CORBA's IR plus an operation <code>resolve(spec)</code> that return a registered IDL type description from a specification that might be an repository ID, an absolute name, an IDL description in Lua or an object from a remote IR.<br>
		<p>
			<i>Usage:</i>
			<pre>
local iface = oil.types:lookup("MyModule::MyInterface")
local iface = oil.types:lookup_id("IDL:MyModule/MyInterface:1.0")
			</pre>
		</dd>
		
		<dt><a name="loadidl"><b><code>oil.loadidl</code></b></a><code>(idlcode)</code></dt>
		<dd>
		<p>
			<b>Loads an IDL definition into the internal Interface Repository.</b>
			The IDL specified will be parsed by the LuaIDL compiler and the resulting
			definitions are updated in the internal interface repository.
			If any errors occurs during the parse no definitions are loaded into the IR.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>idlcode</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>The IDL specification to be loaded into the internal IR</td>
			</tr>
			</table>
		<p>
			<i>Return values</i>
			<table>
			<tr>
				<td valign="top"><code>...</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>IDL descriptors that represents the loaded definitions.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.loadidl [[
  interface Hello {
    attribute boolean quiet;
    readonly attribute unsigned long count;
    string say_hello_to(in string msg);
  };
]]
			</pre>
		</dd>
		
		<dt><a name="loadidlfile"><b><code>oil.loadidlfile</code></b></a><code>(filename)</code></dt>
		<dd>
		<p>
			<b>Loads an IDL file into the internal Interface Repository.</b>
			The IDL file specified will be parsed by the LuaIDL compiler and the resulting
			definitions are updated in the internal interface repository.
			If any errors occurs during the parse no definitions are loaded into the IR.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>filename</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>Path to the IDL file that must be loaded</td>
			</tr>
			</table>
		<p>
			<i>Return values</i>
			<table>
			<tr>
				<td valign="top"><code>...</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>IDL descriptors that represents the loaded definitions.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.loadidlfile "/usr/local/corba/idl/CosNaming.idl"
			</pre>
		</dd>
		
		<dt><a name="getLIR"><b><code>oil.getLIR</code></b></a><code>()</code></dt>
		<dd>
		<p>
			<b>Gets a reference to the integrated Interface Repository.</b>
			Function used to retrieve a reference to the integrated Interface Repository.
			It returns a reference to the object that implements the internal Interface Repository and exports local cached interface definitions.<br>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>localIR</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>CORBA object that exports the internal Interface Repository.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
print("Local IR IOR is:", oil.tostring(oil.getLIR()))
			</pre>
		</dd>
		
		<dt><a name="setIR"><b><code>oil.setIR</code></b></a><code>(remoteIR)</code></dt>
		<dd>
		<p>
			<b>Sets the Interface Repository used to retrieve interface definitions.</b>
			Function used to set the remote Interface Repository that must be used to retrieve interface definitions not stored in the internal IR.
			Once these definitions are acquired, they are stored in the internal IR.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>remoteIR</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Proxy for the remote IR to be used</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.setIR(oil.newproxy("corbaloc::coshost:8080/InterfaceRepository"))
			</pre>
		</dd>
		
		<dt><a name="getIR"><b><code>oil.getIR</code></b></a><code>()</code></dt>
		<dd>
		<p>
			<b> Gets the Interface Repository used to retrieve interface definitions.</b>
			Function used to get a reference to the Interface Repository used to retrieve interface definitions not stored in the internal IR.<br>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>remoteIR</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Proxy to the remote IR currently used.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.getIR():lookup("::MyModule::MyInterface")
			</pre>
		</dd>
		
		<dt><a name="newservant"><b><code>oil.newservant</code></b></a><code>(impl, interface, [key])</code></dt>
		<dd>
		<p>
			<b> Creates a new servant from a table containing operations and attribute values.</b>
			Function used to create a new servant from a table containing attribute values and operation implementations.
			The value of <code>impl</code> is used as the implementation of the a servant with interface defined by parameter <code>interface</code> (e.g. repository ID or absolute name of a given IDL interface stored in the IR).
			Optionally, an object key value may be specified to create persistent references.
			The servant returned by this function offers all servant attributes and methods, as well as implicit basic operations like CORBA's <code>_interface</code> or <code>_is_a</code>.
			After this call any requests which object key matches the key of the servant are dispatched to its implementation.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>impl</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Value used as the servant implementation (may be an indexable value, e.g. userdata with a metatable that defines the __index field)</td>
			</tr>
			<tr>
				<td valign="top"><code>interface</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>Repository ID or absolute name of the interface the object supports</td>
			</tr>
			<tr>
				<td valign="top"><code>key</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top">[optional]</td>
				<td>User-defined object key used in creation of the object reference</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>object</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Servant created.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.newservant({say_hello_to=print}, "IDL:HelloWorld/Hello:1.0")
oil.newservant({say_hello_to=print}, "::HelloWorld::Hello")
oil.newservant({say_hello_to=print}, "::HelloWorld::Hello", "Key")
			</pre>
		</dd>
		
		<dt><a name="deactivate"><b><code>oil.deactivate</code></b></a><code>(object)</code></dt>
		<dd>
		<p>
			<b>Deactivates a servant by removing its implementation from the object map.</b>
			If <code>object</code> is a servant (i.e. the object returned by <code>newservant</code>) then it is deactivated.
			Alternatively, the <code>object</code> parameter may be the servant's object key.
			Only in the case that the servant was created with an implicitly created key by the ORB then the <code>object</code> can be the servant's implementation.
			Since a single implementation object can be used to create many servants with different interface, in this case the <code>type</code> parameter must be provided with the exact servant's interface.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>object</code></td>
				<td valign="top"><b>table|string</b></td>
				<td valign="top"></td>
				<td>Servant's object key, servant's implementation or servant itself.</td>
			</tr>
			<tr>
				<td valign="top"><code>interface</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top">[occasional]</td>
				<td>Identification of the servant's interface (e.g. repository ID or absolute name).</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.deactivate(oil.newservant(impl, "::MyInterface", "objkey"))
oil.deactivate("objkey")
oil.deactivate(impl, "MyInterface")
			</pre>
		</dd>
		
		<dt><a name="tostring"><b><code>oil.tostring</code></b></a><code>(object)</code></dt>
		<dd>
		<p>
			<b>Returns textual information that identifies the servant.</b>
			This function is used to get textual information that references a servant or proxy like an IOR (Inter-operable Object Reference).<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>object</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Servant's object key, servant's implementation or servant itself.</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>textualref</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>Textual reference to the servant.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.writeto("ref.ior", oil.tostring(oil.newservant(impl, "::Hello")))
			</pre>
		</dd>
		
		<dt><a name="newproxy"><b><code>oil.newproxy</code></b></a><code>(reference, [interface])</code></dt>
		<dd>
		<p>
			<b>Creates a proxy for a remote object defined by a textual reference.</b>
			The value of reference must be a string containing reference information of the object the new new proxy will represent like a stringfied IOR (Inter-operable Object Reference) or corbaloc.
			Optionally, an interface supported by the remote object may be defined, in this case no attempt is made to determine the actual object interface, i.e. no network communication is made to check the object's interface.<br>
		<p>
			<i>Parameters</i>
			<table>
			<tr>
				<td valign="top"><code>reference</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>Textual representation of object's reference the new proxy will represent.</td>
			</tr>
			<tr>
				<td valign="top"><code>interface</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top">[optional]</td>
				<td>Interface identification in the interface repository, like a repID or absolute name of a interface the remote object supports (no interface or type check is done).</td>
			</tr>
	  	</table>
		<p>
			<i>Return values</i>
			<table>
			<tr>
				<td valign="top"><code>proxy</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Proxy to the referenced object.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.newproxy("IOR:00000002B494...")
oil.newproxy("IOR:00000002B494...", "HelloWorld::Hello")
oil.newproxy("IOR:00000002B494...", "IDL:HelloWorld/Hello:1.0")
oil.newproxy("corbaloc::host:8080/Key", "IDL:HelloWorld/Hello:1.0")
			</pre>
		</dd>
	
		<dt><a name="narrow"><b><code>oil.narrow</code></b></a><code>(proxy, [interface])</code></dt>
		<dd>
		<p>
			<b>Narrows an object reference into some more specific interface.</b>
			Function used to narrow an object proxy into some more specific interface.
			If you wish to create a narrowed proxy from an IOR or corbaloc URL, use the <code>oil.newproxy</code> function.
			The interface the object reference must be narrowed into is defined by the repository ID or absolute name stored in parameter <code>interface</code>.
			If no interface is defined, then the object reference is narrowed to the most specific interface supported by the COBRA object.
			Note that in the former case, no attempt is made to determine the actual object interface, <em>i.e.</em> no network communication is made to check the object's interface.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>proxy</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Proxy of a CORBA object that must be narrowed</td>
			</tr>
			<tr>
				<td valign="top"><code>interface</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top">[optional]</td>
				<td>Repository Interface ID or absolute name of the interface the object reference must be narrowed into (no interface or type check is made)</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>proxy</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Proxy to the CORBA object narrowed into some interface supported by the CORBA object.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.narrow(ns:resolve_str("HelloWorld"))
oil.narrow(ns:resolve_str("HelloWorld"), "IDL:HelloWorld/Hello:1.0")
oil.narrow(ns:resolve_str("HelloWorld"), "::HelloWorld::Hello")
			</pre>
		<p>
			<i>See also:</i> <a href="#newproxy"><b><code>oil.newproxy</code></b></a>
		</dd>
		
		<dt><a name="tasks"><b><code>oil.tasks</code></b></a></dt>
		<dd>
		<p>
			<b>Internal coroutine scheduler used by OiL.</b>
			This field holds a reference to the object that implement the API described in <a href="http://loop.luaforge.net/docs_Scheduler.html">loop.thread.Scheduler</a>.<br>
		<p>
			<i>Usage:</i>
			<pre>
oil.tasks:register(coroutine.create(oil.run))
oil.tasks:run()
			</pre>
		</dd>
		
		<dt><a name="main"><b><code>oil.main</code></b></a><code>(func)</code></dt>
		<dd>
		<p>
			<b>Executes the main function of the application.</b>
			The application's main function is executed in a new thread if the current assembly provides thread support.
			This may only return when the application terminates.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>func</code></td>
				<td valign="top"><b>function</b></td>
				<td valign="top"></td>
				<td>Application's main function.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.main(oil.run)
oil.main(function() print(oil.tostring(oil.getLIR())) oil.run() end)
			</pre>
		</dd>
		
		<dt><a name="newthread"><b><code>oil.newthread</code></b></a><code>(func, ...)</code></dt>
		<dd>
		<p>
			<b>Creates and starts the execution of a new the thread.</b>
			Creates a new thread to execute the function <code>func</code> with the extra parameters provided.
			This function imediately starts the execution of the new thread and the original thread is only resumed again acordingly to the the scheduler's internal policy.
			This function can only be invocated from others threads, including the one executing the application's main function (see <code>main</code>).<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>func</code></td>
				<td valign="top"><b>function</b></td>
				<td valign="top"></td>
				<td>Function that the new thread will execute.</td>
			</tr>
			<tr>
				<td valign="top"><code>...</code></td>
				<td valign="top"><b>any</b></td>
				<td valign="top"></td>
				<td>Additional parameters passed to the <code>func</code> function.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.main(function()
	oil.newthread(oil.run)
	oil.newproxy(oil.readfrom("ior")):register(localobj)
end)
			</pre>
		<p>
			<i>See also:</i> <a href="#main"><b><code>oil.main</code></b></a>
		</dd>
		
		<dt><a name="sleep"><b><code>oil.sleep</code></b></a><code>(time)</code></dt>
		<dd>
		<p>
			<b>Suspends the execution of the current thread for some time.</b>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>time</code></td>
				<td valign="top"><b>number</b></td>
				<td valign="top"></td>
				<td>Delay in seconds that the execution must be resumed.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.sleep(5.5)
			</pre>
		</dd>
		
		<dt><a name="time"><b><code>oil.time</code></b></a><code>()</code></dt>
		<dd>
		<p>
			<b>Get the current system time.</b>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>timestamp</code></td>
				<td valign="top"><b>number</b></td>
				<td valign="top"></td>
				<td>Number of seconds since a fixed point in the past.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
local start = oil.time(); oil.sleep(3); print("I slept for", oil.time() - start)
			</pre>
		</dd>
		
		<dt><a name="pcall"><b><code>oil.pcall</code></b></a><code>(func, ...)</code></dt>
		<dd>
		<p>
			<b>Function that must be used to perform protected calls in applications.</b>
			It is a "coroutine-safe" version of the <code>pcall</code> function of the Lua standard library.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>func</code></td>
				<td valign="top"><b>function</b></td>
				<td valign="top"></td>
				<td>Function to be executed in protected mode.</td>
			</tr>
			<tr>
				<td valign="top"><code>...</code></td>
				<td valign="top"><b>any</b></td>
				<td valign="top"></td>
				<td>Additional parameters passed to protected function.</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>success</code></td>
				<td valign="top"><b>boolean</b></td>
				<td valign="top"></td>
				<td><code>true</code> if function execution did not raised any errors or <code>false</code> otherwise.</td>
			</tr>
			<tr>
				<td valign="top"><code>...</code></td>
				<td valign="top"><b>any</b></td>
				<td valign="top"></td>
				<td>Values returned by the function or an the error raised by the function.</td>
			</tr>
			</table>
		</dd>
		
		<dt><a name="newdecoder"><b><code>oil.newdecoder</code></b></a><code>(stream)</code></dt>
		<dd>
		<p>
			<b>Creates a new value decoder that extracts marshaled values from strings.</b>
			The decoder reads CORBA's CDR encapsulated streams, <i>i.e.</i> includes an indication of the endianess used in value codification.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>stream</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>String containing a stream with marshaled values.</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>decoder</code></td>
				<td valign="top"><b>object</b></td>
				<td valign="top"></td>
				<td>Value decoder that provides operation 'get([type])' to unmarshal values from a marshaled stream.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
local decoder = oil.newdecoder(stream)
val = decoder:get(oil.corba.idl.sequence{oil.corba.idl.long})
val = decoder:get(oil.types:lookup("MyLongSeq"))
			</pre>
		</dd>
		
		<dt><a name="newencoder"><b><code>oil.newencoder</code></b></a><code>()</code></dt>
		<dd>
		<p>
			<b>Creates a new value encoder that marshal values into strings.</b>
			The encoder marshals values in a CORBA's CDR encapsulated stream, <i>i.e.</i> includes an indication of the endianess used in value codification.<br>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>encoder</code></td>
				<td valign="top"><b>object</b></td>
				<td valign="top"></td>
				<td>Value encoder that provides operation 'put(value, [type])' to marshal values and operation 'getdata()' to get the marshaled stream.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
local encoder = oil.newencoder()
encoder:put({1,2,3}, oil.corba.idl.sequence{oil.corba.idl.long})
encoder:put({1,2,3}, oil.types:lookup("MyLongSeq"))
io.write(encoder:getdata())
			</pre>
		</dd>
		
		<dt><a name="newexcept"><b><code>oil.newexcept</code></b></a><code>(body)</code></dt>
		<dd>
		<p>
			<b>Creates a new exception object with the given body.</b>
			The <code>body</code> must contain the values of the exceptions fields and must also contain the exception identification in index 1 (in CORBA this identification is the repository ID, absolute name, etc.).<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>body</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Exception body with all its field values and exception ID.</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>exception</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top"></td>
				<td>Exception that provides meta-method <code>__tostring</code> that provides a pretty-printing.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
error(oil.newexcept{ "::CORBA::INTERNAL", minor_code_value = 2 })
			</pre>
		</dd>
		
		<dt><a name="setexcatch"><b><code>oil.setexcatch</code></b></a><code>(func [, interface])</code></dt>
		<dd>
		<p>
			<b>Defines a exception handling function for proxies.</b>
			The handling function receives the following parameters:<br>
			<b>proxy</b>: object proxy that performed the operation.<br>
			<b>exception</b>: exception/error raised.<br>
			<b>operation</b>: descriptor of the operation that raised the exception.<br>
			If the parameter <code>type</code> is provided, then the exception handling function will be applied only to proxies of that type (i.e. interface).
			Exception handling functions are nor cumulative.
			For example, is the is an exception handling function defined for all proxies and other only for proxies of a given type, then the later will be used for proxies of that given type.
			Additionally, exceptions handlers are not inherited through interface hierarchies.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>func</code></td>
				<td valign="top"><b>function</b></td>
				<td valign="top"></td>
				<td>Exception handling function.</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>interface</code></td>
				<td valign="top"><b>table</b></td>
				<td valign="top">[optional]</td>
				<td>Interface ID of a group of proxies (e.g. repID).</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
oil.setexcatch(function(_, except) error(tostring(except)) end)
			</pre>
		</dd>
		
		<dt><a name="setclientinterceptor"><b><code>oil.setclientinterceptor</code></b></a><code>([interceptor])</code></dt>
		<dd>
		<p>
			<b>Sets a CORBA-specific interceptor for operation invocations in the client-size.</b>
			The interceptor must provide the following operations:<br>
			<ul>
				<li>
					<code>sendrequest(request)</code>: <code>request</code> structure is described below.
					<table>
					<tr>
						<td valign="top"><code>response_expected</code></td>
						<td valign="top"><b>boolean</b></td>
						<td valign="top">[read-only]</td>
						<td>Flag that indicates if the server must send a response for this request.</td>
					</tr>
					<tr>
						<td valign="top"><code>object_key</code></td>
						<td valign="top"><b>string</b></td>
						<td valign="top">[read-only]</td>
						<td>Key of the object the request is addressed to.</td>
					</tr>
					<tr>
						<td valign="top"><code>operation</code></td>
						<td valign="top"><b>string</b></td>
						<td valign="top">[read-only]</td>
						<td>Name of the operation being invoked.</td>
					</tr>
					<tr>
						<td valign="top"><code>service_context</code></td>
						<td valign="top"><b>table</b></td>
						<td valign="top"></td>
						<td>Defines the service context values. See <code>ServiceContextList</code> in CORBA specs.</td>
					</tr>
					<tr>
						<td valign="top"><code>success</code></td>
						<td valign="top"><b>boolean</b></td>
						<td valign="top">[optional]</td>
						<td>Set this value to cancel request and define the results:
						<code>true</code> cancels the request and indicates to the application that invocation was successful;
						<code>false</code> cancels the request and indicates to the application that invocation raised an exception.</td>
					</tr>
					</table>
					<a name="#client-params-note">Note:</a> The integer indexes store the operation's parameter values and should also be used to store the results values if the request is canceled (see <a href="#client-return-note">note below</a>).
					<br>
					<br>
				</li>
				<li>
					<code>receivereply(reply)</code>: <code>reply</code> structure is described below.
					<table>
					<tr>
						<td valign="top"><code>service_context</code></td>
						<td valign="top"><b>table</b></td>
						<td valign="top">[read-only]</td>
						<td>Service context present in reply message. See <code>ServiceContextList</code> in CORBA specs.</td>
					</tr>
					<tr>
						<td valign="top"><code>reply_status</code></td>
						<td valign="top"><b>string</b></td>
						<td valign="top">[read-only]</td>
						<td>Enumeration value that indicates the reply status. See <code>ReplyStatus</code> in CORBA specs.</td>
					</tr>
					<tr>
						<td valign="top"><code>success</code></td>
						<td valign="top"><b>boolean</b></td>
						<td valign="top">[optional]</td>
						<td>Set this value to cancel the reply and replace results:
						<code>true</code> cancels the reply and indicates to the application that invocation was successful;
						<code>false</code> cancels the reply and indicates to the application that invocation raised an exception.</td>
					</tr>
					</table>
					<a name="client-return-note">Note:</a> The integer indexes store the results that will be sent as request result.
					For successful invocations these values must be the operation's results (return, out and inout parameters) in the same order they appear in the IDL description.
					For failed invocations, index 1 must be the exception that identifies the failure.
				</li>
			</ul>
			<br>
			The <code>request</code> and <code>reply</code> are the same table in a single invocation.
			Therefore, the fields of <code>request</code> are also available in <code>reply</code> except for those defined in the description of <code>reply</code>.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>interceptor</code></td>
				<td valign="top"><b>object</b></td>
				<td valign="top">[optional]</td>
				<td>Interceptor object that must provide the interface described above. If no value or <code>nil</code> is provided the the current interceptor is unregistered from the ORB.</td>
			</tr>
			</table>
		</dd>

		<dt><a name="setserverinterceptor"><b><code>oil.setserverinterceptor</code></b></a><code>([interceptor])</code></dt>
		<dd>
		<p>
			<b>Sets a CORBA-specific interceptor for operation invocations in the server-size.</b>
			The interceptor must provide the following operations:<br>
			<ul>
				<li>
					<code>receiverequest(request)</code>: <code>request</code> structure is described below.
					<table>
					<tr>
						<td valign="top"><code>service_context</code></td>
						<td valign="top"><b>table</b></td>
						<td valign="top">[read-only]</td>
						<td>Service context present in reply message. See <code>ServiceContextList</code> in CORBA specs.</td>
					</tr>
					<tr>
						<td valign="top"><code>request_id</code></td>
						<td valign="top"><b>number</b></td>
						<td valign="top">[read-only]</td>
						<td>Number that identifies the request in the multiplexed channel.</td>
					</tr>
					<tr>
						<td valign="top"><code>response_expected</code></td>
						<td valign="top"><b>boolean</b></td>
						<td valign="top">[read-only]</td>
						<td>Flag that indicates if the server must send a response for this request.</td>
					</tr>
					<tr>
						<td valign="top"><code>object_key</code></td>
						<td valign="top"><b>string</b></td>
						<td valign="top">[read-only]</td>
						<td>Key of the object the request is addressed to.</td>
					</tr>
					<tr>
						<td valign="top"><code>operation</code></td>
						<td valign="top"><b>string</b></td>
						<td valign="top">[read-only]</td>
						<td>Name of the operation being invoked.</td>
					</tr>
					<tr>
						<td valign="top"><code>servant</code></td>
						<td valign="top"><b>object</b></td>
						<td valign="top">[read-only]</td>
						<td>Local object the invocation will be dispatched to.</td>
					</tr>
					<tr>
						<td valign="top"><code>method</code></td>
						<td valign="top"><b>function</b></td>
						<td valign="top">[read-only]</td>
						<td>Function that will be invoked on object <code>servant</code>.</td>
					</tr>
					<tr>
						<td valign="top"><code>success</code></td>
						<td valign="top"><b>boolean</b></td>
						<td valign="top">[optional]</td>
						<td>Set this value to cancel the request and define the results:
						<code>true</code> cancels the request and indicates to the application that invocation was successful;
						<code>false</code> cancels the request and indicates to the application that invocation raised an exception.</td>
					</tr>
					</table>
					<a name="#server-params-note">Note:</a> The integer indexes store the operation's parameter values and should also be used to store the results values if the request is canceled (see <a href="#server-return-note">note below</a>).
					<br>
					<br>
				</li>
				<li>
					<code>sendreply(reply)</code>: <code>reply</code> structure is described below.
					<table>
					<tr>
						<td valign="top"><code>service_context</code></td>
						<td valign="top"><b>table</b></td>
						<td valign="top"></td>
						<td>Set this value to define a service context values. See <code>ServiceContextList</code> in CORBA specs.</td>
					</tr>
					<tr>
						<td valign="top"><code>success</code></td>
						<td valign="top"><b>boolean</b></td>
						<td valign="top">[optional]</td>
						<td>Set this value to cancel the reply and replace results:
						<code>true</code> cancels the reply and indicates to the application that invocation was successful;
						<code>false</code> cancels the reply and indicates to the application that invocation raised an exception.</td>
					</tr>
					</table>
					<a name="server-return-note">Note:</a> The integer indexes store the results that will be sent as request result.
					For successful invocations these values must be the operation's results (return, out and inout parameters) in the same order they appear in the IDL description.
					For failed invocations, index 1 must be the exception that identifies the failure.
				</li>
			</ul>
			<br>
			The <code>request</code> and <code>reply</code> are the same table in a single invocation.
			Therefore, the fields of <code>request</code> are also available in <code>reply</code> except for those defined in the description of <code>reply</code>.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>interceptor</code></td>
				<td valign="top"><b>object</b></td>
				<td valign="top">[optional]</td>
				<td>Interceptor object that must provide the interface described above. If no value or <code>nil</code> is provided the the current interceptor is unregistered from the ORB.</td>
			</tr>
			</table>
		</dd>
		
		<dt><a name="writeto"><b><code>oil.writeto</code></b></a><code>(filepath, text)</code></dt>
		<dd>
		<p>
			<b>Writes a text into file.</b>
			Utility function for writing stringfied IORs into a file.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>filepath</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>Path of the file that should be create with the text provided.</td>
			</tr>
			<tr>
				<td valign="top"><code>text</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>Text that shall be written into the file.</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>success</code></td>
				<td valign="top"><b>file handler</b></td>
				<td valign="top"></td>
				<td>If the file was properly created with the provided content then the closed file handler is returned or <code>nil</code> is returned if some error was found.</td>
			</tr>
			<tr>
				<td valign="top"><code>error</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top">[occasional]</td>
				<td>Error message returned by function 'io.open' of Lua IO library if the file could not be opened for write.</td>
			</tr>
			</table>
		<p>
			<i>Usage:</i>
			<pre>
			</pre>
		</dd>
		
		<dt><a name="readfrom"><b><code>oil.readfrom</code></b></a><code>(filepath)</code></dt>
		<dd>
		<p>
			<b>Read the contents of a file.</b>
			Utility function for reading stringfied IORs from a file.<br>
		<p>
			<i>Parameters:</i>
			<table>
			<tr>
				<td valign="top"><code>success</code></td>
				<td valign="top"><b>file handler</b></td>
				<td valign="top"></td>
				<td>Path of the file to be read.</td>
			</tr>
			</table>
		<p>
			<i>Return values:</i>
			<table>
			<tr>
				<td valign="top"><code>contents</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top"></td>
				<td>Contents of the file read or <code>nil</code> if some error was found.</td>
			</tr>
			<tr>
				<td valign="top"><code>error</code></td>
				<td valign="top"><b>string</b></td>
				<td valign="top">[occasional]</td>
				<td>Error message returned by function 'io.open' of Lua IO library if the file could not be opened for read.</td>
			</tr>
			</table>
		</dd>
		
		<dt><a name="createservant"><b><code>oil.createservant</code></b></a><code>(impl, interface, [key])</code></dt>
		<dd>
		<p>
			<b>Alias of <code>newservant</code> function.</b>
			For compatibility with LuaOrb applications.<br>
		<p>
			<i>See also:</i> <a href="#newservant"><b><code>oil.newservant</code></b></a>
		</dd>
	
		<dt><a name="createproxy"><b><code>oil.createproxy</code></b></a><code>(reference, [interface])</code></dt>
		<dd>
		<p>
			<b>Alias of <code>newproxy</code> function.</b>
			For compatibility with LuaOrb applications.<br>
		<p>
			<i>See also:</i> <a href="#newproxy"><b><code>oil.newproxy</code></b></a>
		</dd>
	
	</dl>	
</div>

<div class="content">
	<h3><small>Copyright (C) 2004-2005 Tecgraf, PUC-Rio</small></h3>
	<small>This project is currently being maintained by <a href="http://www.tecgraf.puc-rio.br">Tecgraf</a> at <a href="http://www.puc-rio.br">PUC-Rio</a> with grants by <a href="http://www.capes.gov.br">CAPES</a> and <a href="http://www.cnpq.br">CNPq</a>.</small>
</div>

<div id="Board">
</div>

<!-- BlueRobot was here. -->

</body>

</html>